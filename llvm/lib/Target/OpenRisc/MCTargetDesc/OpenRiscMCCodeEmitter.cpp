//===-- OpenRiscMCCodeEmitter.cpp - Convert OpenRisc Code to Machine Code -----===//
//
//                     The LLVM Compiler Infrastructure
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements the OpenRiscMCCodeEmitter class.
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/OpenRiscFixupKinds.h"
#include "MCTargetDesc/OpenRiscMCExpr.h"
#include "MCTargetDesc/OpenRiscMCTargetDesc.h"
#include "llvm/MC/MCCodeEmitter.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/Support/Casting.h"

#define GET_INSTRMAP_INFO
#include "OpenRiscGenInstrInfo.inc"
#undef GET_INSTRMAP_INFO

using namespace llvm;

#define DEBUG_TYPE "mccodeemitter"

namespace {
class OpenRiscMCCodeEmitter : public MCCodeEmitter {
  const MCInstrInfo &MCII;
  MCContext &Ctx;
  bool isLittleEndian;

public:
  OpenRiscMCCodeEmitter(const MCInstrInfo &mcii, MCContext &ctx, bool isLE)
      : MCII(mcii), Ctx(ctx), isLittleEndian(isLE) {}

  ~OpenRiscMCCodeEmitter() {}

  // Override MCCodeEmitter.
  void encodeInstruction(const MCInst &MI, SmallVectorImpl<char> &CB,
                         SmallVectorImpl<MCFixup> &Fixups,
                         const MCSubtargetInfo &STI) const override;

private:
  // Automatically generated by TableGen.
  uint64_t getBinaryCodeForInstr(const MCInst &MI,
                                 SmallVectorImpl<MCFixup> &Fixups,
                                 const MCSubtargetInfo &STI) const;

  uint32_t getExprOpValue(const MCExpr *Expr,
                          SmallVectorImpl<MCFixup> &Fixups,
                          const MCSubtargetInfo &STI) const;

  // Called by the TableGen code to get the binary encoding of operand
  // MO in MI.  Fixups is the list of fixups against MI.
  uint32_t getMachineOpValue(const MCInst &MI, const MCOperand &MO,
                             SmallVectorImpl<MCFixup> &Fixups,
                             const MCSubtargetInfo &STI) const;

  uint32_t getBranchTargetEncoding(const MCInst &MI, unsigned int OpNum,
                                   SmallVectorImpl<MCFixup> &Fixups,
                                   const MCSubtargetInfo &STI) const;

  uint32_t getCallEncoding(const MCInst &MI, unsigned int OpNum,
                           SmallVectorImpl<MCFixup> &Fixups,
                           const MCSubtargetInfo &STI) const;
  
  uint32_t getSImm16OpValue(const MCInst &MI, unsigned OpNum,
                              SmallVectorImpl<MCFixup> &Fixups,
                              const MCSubtargetInfo &STI) const;

  uint32_t getUImm5OpValue(const MCInst &MI, unsigned OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const;
    
  uint32_t getUImm16OpValue(const MCInst &MI, unsigned OpNum,
                              SmallVectorImpl<MCFixup> &Fixups,
                              const MCSubtargetInfo &STI) const;

  uint32_t getImm16OpValue(const MCInst &MI, unsigned OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const;
  
  uint32_t getImm32OpValue(const MCInst &MI, unsigned OpNum,
                              SmallVectorImpl<MCFixup> &Fixups,
                              const MCSubtargetInfo &STI) const;

  uint32_t getImm16HighOpValue(const MCInst &MI, unsigned OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const;
};
} // namespace

MCCodeEmitter *llvm::createOpenRiscMCCodeEmitter(const MCInstrInfo &MCII,
                                               MCContext &Ctx) {
  return new OpenRiscMCCodeEmitter(MCII, Ctx, false);
}

void OpenRiscMCCodeEmitter::encodeInstruction(const MCInst &MI,
                                            SmallVectorImpl<char> &CB,
                                            SmallVectorImpl<MCFixup> &Fixups,
                                            const MCSubtargetInfo &STI) const {
  uint64_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
  unsigned Size = MCII.get(MI.getOpcode()).getSize();

  if (!isLittleEndian) {
    // Big-endian insertion of Size bytes.
    for (unsigned I = 0; I != Size; ++I) {
      unsigned ShiftValue = 8 * (Size - 1 - I);
      CB.push_back(char(Bits >> ShiftValue));
    }
  } else {
    llvm_unreachable("Little-endian mode currently is not supported!");
  }
}

uint32_t
OpenRiscMCCodeEmitter::getMachineOpValue(const MCInst &MI, const MCOperand &MO,
                                       SmallVectorImpl<MCFixup> &Fixups,
                                       const MCSubtargetInfo &STI) const {
  if (MO.isReg())
    return Ctx.getRegisterInfo()->getEncodingValue(MO.getReg());
  if (MO.isImm()) {
    uint32_t Res = static_cast<uint32_t>(MO.getImm());
    return Res;
  }

  llvm_unreachable("Unhandled expression!");
  return 0;
}

uint32_t
OpenRiscMCCodeEmitter::getBranchTargetEncoding(const MCInst &MI, unsigned int OpNum,
                                           SmallVectorImpl<MCFixup> &Fixups,
                                           const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return MO.getImm();

  const MCExpr *Expr = MO.getExpr();
  Fixups.push_back(MCFixup::create(
      0, Expr, MCFixupKind(OpenRisc::fixup_openrisc_jump_18), MI.getLoc()));
  return 0;
}

uint32_t
OpenRiscMCCodeEmitter::getCallEncoding(const MCInst &MI, unsigned int OpNum,
                                     SmallVectorImpl<MCFixup> &Fixups,
                                     const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);
  if (MO.isImm()) {
    int32_t Res = MO.getImm();
    if (Res & 0x3) {
      llvm_unreachable("Unexpected operand value!");
  return 0;;
    }
    Res >>= 2;
    return Res;
  }

  assert((MO.isExpr()) && "Unexpected operand value!");
  const MCExpr *Expr = MO.getExpr();
  Fixups.push_back(MCFixup::create(
      0, Expr, MCFixupKind(OpenRisc::fixup_openrisc_call_18), MI.getLoc()));
  return 0;
}

uint32_t
OpenRiscMCCodeEmitter::getSImm16OpValue(const MCInst &MI, unsigned OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return MO.getImm();
  
  llvm_unreachable("Unexpected operand value!");
}

uint32_t
OpenRiscMCCodeEmitter::getUImm5OpValue(const MCInst &MI, unsigned OpNum,
                          SmallVectorImpl<MCFixup> &Fixups,
                          const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return static_cast<uint32_t>(MO.getImm());
  
  llvm_unreachable("Unexpected operand value!");
}
  
uint32_t
OpenRiscMCCodeEmitter::getUImm16OpValue(const MCInst &MI, unsigned OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return static_cast<uint32_t>(MO.getImm());
  
  llvm_unreachable("Unexpected operand value!");
}

uint32_t
OpenRiscMCCodeEmitter::getImm16OpValue(const MCInst &MI, unsigned OpNum,
                          SmallVectorImpl<MCFixup> &Fixups,
                          const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return MO.getImm();
  
  llvm_unreachable("Unexpected operand value!");
}

uint32_t
OpenRiscMCCodeEmitter::getImm32OpValue(const MCInst &MI, unsigned OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return MO.getImm();
  
  llvm_unreachable("Unexpected operand value!");
}

unsigned OpenRiscMCCodeEmitter::getExprOpValue(const MCExpr *Expr,
                                          SmallVectorImpl<MCFixup> &Fixups,
                                          const MCSubtargetInfo &STI) const {

  MCExpr::ExprKind Kind = Expr->getKind();

  if (Kind == MCExpr::Binary) {
    Expr = static_cast<const MCBinaryExpr *>(Expr)->getLHS();
    Kind = Expr->getKind();
  }

  /*
  if (Kind == MCExpr::Target) {
    OpenRiscMCExpr const *OpenRiscExpr = cast<OpenRiscMCExpr>(Expr);
    int64_t Result;
    if (OpenRiscExpr->evaluateAsConstant(Result)) {
      return Result;
    }

    MCFixupKind FixupKind = static_cast<MCFixupKind>(OpenRiscExpr->getFixupKind());
    Fixups.push_back(MCFixup::create(0, OpenRiscExpr, FixupKind));
    return 0;
  }
  */

  assert(Kind == MCExpr::SymbolRef);
  return 0;
}

uint32_t
OpenRiscMCCodeEmitter::getImm16HighOpValue(const MCInst &MI, unsigned OpNum,
                          SmallVectorImpl<MCFixup> &Fixups,
                          const MCSubtargetInfo &STI) const {
  const MCOperand &MO = MI.getOperand(OpNum);

  if (MO.isImm())
    return MO.getImm();
  
  // MO must be an Expr.
  assert(MO.isExpr());

  return getExprOpValue(MO.getExpr(), Fixups, STI);
}

#include "OpenRiscGenMCCodeEmitter.inc"
